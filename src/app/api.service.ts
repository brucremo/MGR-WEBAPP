import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from './user';
import { map } from 'rxjs/operators';

//Headers for requests sent to the API
const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  //API URL
  public api = "https://mgr-restapi.herokuapp.com";

  //For API local testing
  //public api = "http://localhost:8082"

  constructor(
    private http: HttpClient
  ) { }

  //--------------------------------- USER INFORMATION REQUESTS ---------------------------------

  //GET: /users (returns all users information except for password)
  getUsers() {

    return this.http.get<User[]>(`${this.api}/users`);
  }

  //GET: /users/:userid (return single user information except for password)
  getUser(user: User): Observable<any> {

    return this.http.get<User>(`${this.api}/users/${user.USERID}`);
  }

  //POST: /users (add user to the system and hash store its password on the database)
  userAdd(user: User): Observable<any> {

    return this.http.post<any>(`${this.api}/users`, user)
      .pipe(map(wrapper => wrapper.message))
  }

  //PUT: /users/:userid (updates single user information)
  useredit(user: User): Observable<any> {

    return this.http.put<any>(`${this.api}/users/${user.USERID}`, user)
      .pipe(map(wrapper => wrapper.message))
  }

  //DELETE: /users/:userid (deletes single user from the database)
  userDelete(user: User) {

    return this.http.delete<User[]>(`${this.api}/users/${user.USERID}`);
  }

  //--------------------------------- PASSWORD MANAGEMENT REQUESTS ---------------------------------

  /*PUT: /users/:userid/pwd -> Checks if the USERNAME + USERPASSWORD pair is valid on logon based on the hashed value stored in the database.*/
  userLogin(user: User): Observable<any> {

    return this.http.put<User>(`${this.api}/users/${user.USERID}/pwd`, user, httpOptions);
  }

  //--------------------------------- PASSWORD RESET REQUESTS ---------------------------------

  /*GET: /:id/reset/:guid -> The GUID is generated by the API and the user will access our website with this link to reset its password. 
  The GUID will be checked for validity, if it is valid it will return a User object with only USERID and USERNAME, otherwise the API will return a 404 error.*/
  userCredentialCheck(user: User, GUID): Observable<any> {

    return this.http.get<User>(`${this.api}/${user.USERID}/reset/${GUID}`);
  }

  /* PUT: /:id/reset/ -> Receives an object with the USERID and USEREMAIL to have its password reset. 
  This function will send the user an Email with instructions to reset its password. 
  The object sent to it must be sent in the following form (notice the single quotes around the Email address, they are required): 
  {"USERID":"usr", "USEREMAIL":"'email@me.com'"} */
  userPasswordReset(user: User): Observable<any> {

    return this.http.put<User>(`${this.api}/${user.USERID}/reset`, user, httpOptions);
  }

  /* POST: /:id/reset -> Receives an object with the USERID and USERPASSWORD to have its password reset. 
  It simply sets the selected user's password to the password provided in the object and returns the object with USERPASSWORD set to true. */
  userPasswordChange(user: User): Observable<any> {

    return this.http.post<User>(`${this.api}/${user.USERID}/reset/`, user);
  }

  //--------------------------------- REVIEW REQUESTS ---------------------------------

  // GET: /reviews/:gameid -> Retrieves all stored reviews for a specific game
  gameGetReviews(gameid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/reviews/${gameid}`);
  }

  // GET: /reviews/:gameid -> Retrieves all stored reviews for a specific game
  userGetReviews(userid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/reviews/user/${userid}`);
  }

  // GET: /review/:gameid/:userid -> Retrieves all stored reviews for a specific game
  getReview(gameid: String, userid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/review/${gameid}/${userid}`);
  }

  /* Object blueprint for POST and PUT ->

    const object = {
        USERID: req.params.userid,
        GAMEID: req.params.gameid,
        REVIEWSUMMARY: req.body.REVIEWSUMMARY,
        REVIEWRATING: req.body.REVIEWRATING,
        GAMEPLATFORM: req.body.GAMEPLATFORM
    };
  */

  /* POST: /review/:gameid/:userid -> Receives an object with USERID, GAMEID, REVIEWSUMMARY, 
  REVIEWRATING and GAMEPLATFORM to be posted for the parameters gameid and userid */
  gameReviewAdd(review: any): Observable<any> {

    return this.http.post<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`, review);
  }

  /* PUT: /review/:gameid/:userid -> Receives an object with USERID, GAMEID, REVIEWSUMMARY, 
  REVIEWRATING and GAMEPLATFORM to be updated for the parameters gameid and userid */
  gameReviewEdit(review: any): Observable<any> {

    return this.http.put<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`, review);
  }

  /* DELETE: /review/:gameid/:userid -> Receives an object with GAMEID and USERID for a review to be deleted from the database */
  gameReviewDelete(review: any): Observable<any> {

    return this.http.delete<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`);
  }

  //--------------------------------- LIBRARY MANAGEMENT ---------------------------------

  // GET: /library/:userid -> Retrieves all stored games associated with a user library
  getUserLibrary(userid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/library/${userid}`);
  }

  // PUT: /library/:userid/:gameid -> Associates a gameid to a user's library
  addToUserLibrary(userid: String, gameid: String): Observable<any> {

    const lib = {
      USERID: userid,
      GAMEID: gameid
    }

    return this.http.put<any>(`${this.api}/library/${lib.USERID}/${lib.GAMEID}`, lib);
  }

  // DELETE: /library/:userid/:gameid -> Removes a gameid from a user's library
  removeFromUserLibrary(userid: String, gameid: String): Observable<any> {

    return this.http.delete<any>(`${this.api}/library/${userid}/${gameid}`);
  }

  // POST: /library/:userid/:gameid -> Toggles game as favourite for the user's library
  setFavourite(userid: String, gameid: String): Observable<any> {

    const lib = {
      USERID: userid,
      GAMEID: gameid
    }

    return this.http.post<any>(`${this.api}/library/${lib.USERID}/${lib.GAMEID}`, lib);
  }

  //--------------------------------- REGISTRATION TOOLS ---------------------------------

  /* GET: /register/get-email/:email -> Returns true if the e-mail passed as parameter already 
  exists in the DB, false otherwise */
  checkEmailDB(email: String): Observable<any> {

    return this.http.get<any>(`${this.api}/register/get-email/${email}`);
  }

  /* GET: /register/get-userid/:userid -> Returns true if the userid passed as parameter already 
  exists in the DB, false otherwise */
  checkUserIDDB(userid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/register/get-userid/${userid}`);
  }

  //--------------------------------- TAG FUNCTIONALITY ---------------------------------

  // GET: /tag/:tagid/:userid -> Returns all games related to a tag in a user's library
  getGamesForTag(userid: String, tagid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/tag/${tagid}/${userid}`);
  }

  // DELETE: /tag/:tagid/:userid -> Removes a tag from a user's library
  removeTag(userid: String, tagid: String): Observable<any> {

    return this.http.delete<any>(`${this.api}/tag/${tagid}/${userid}`);
  }

  // POST: /tag -> Receives an object with USERID, GAMEID, and TAGS array to be added to a user's library
  /* NOTE -> THE GAME MUST BE ADDED TO THE USER'S LIBARY BEFORE RUNNING THIS FUNCTIONS, IN OTHER WORDS 
  addToUserLibrary MUST BE RUN BEFORE ADD TAG(S)*/
  addTags(tags: any): Observable<any> {

    return this.http.post<any>(`${this.api}/tag`, tags);
  }

  //--------------------------------- FRIEND NETWORKING FUNCTIONALITY ---------------------------------
  //ALL FUNCTIONS GO TO ROUTE /friends AND REQUIRE A JS OBJECT AS DESCRIBED ON THE FOOTPRINTS BELOW

  /* 
    {USER_ONE_ID : String, USER_TWO_ID : String, STATUS: Int, ACTION_USERID : String}

    USER_ONE_ID -> One of the users of the connection, can be either the current user or the user 
    receiving the request.

    USER_TWO_ID -> The other user of the connection, can be either the current user or the user 
    receiving the request. CANNOT BE THE SAME AS USER_ONE_ID
    
    STATUS -> Friendship requests status, used to treat requests and filter friends displays. 
    0 => PENDING | 1 => DECLINED/OK | 2 => DECLINED | 3 => BLOCKED (to be fully implemented later)
    
    ACTION_USERID => Last user to alter the friendship status. MUST BE RELEVANT.
  */

  /*GET: Gets all friends for a specific user. 
    Requires the object as follows {USER_ONE_ID : String, STATUS: Int}*/
  getFriends(relationship: any): Observable<any> {

    let params = new HttpParams()
      .set("USER_ONE_ID", relationship.USER_ONE_ID)
      .set("STATUS", relationship.STATUS);

    return this.http.get<any>(`${this.api}/friends`, { params: params });
  }

  /*POST: Adds user as friend and sends it an e-mail with the request if their relationship does not exist yet. 
    Requires the object as follows {USER_ONE_ID : String, USER_TWO_ID : String, ACTION_USERID : String}*/
  addFriend(relationship: any): Observable<any> {
    return this.http.post<any>(`${this.api}/friends`, relationship);
  }

  /*PUT: Updates friendship status between users. 
    Requires the full object with relevant information regarding ACTION_USERID and STATUS*/
  updateFriend(relationship: any): Observable<any> {

    return this.http.put<any>(`${this.api}/friends`, relationship);
  }

  /*DELETE: Removes friendship links between users. 
    Requires the object as follows {USER_ONE_ID : String, USER_TWO_ID : String}*/
  deleteFriend(relationship: any): Observable<any> {
    let params = new HttpParams()
      .set("USER_ONE_ID", relationship.USER_ONE_ID)
      .set("USER_TWO_ID", relationship.USER_TWO_ID);

    return this.http.delete<any>(`${this.api}/friends`, { params: params });
  }

  //--------------------------------- GROUP/USER SEARCH FUNCTIONALITY ---------------------------------
  //GET: Searches for a specific USERID
  searchUSERID(USERID: any): Observable<any> {

    let params = new HttpParams()
      .set("USERID", USERID);

    return this.http.get<any>(`${this.api}/search`, { params: params });
  }

  //GET: Searches for a specific USEREMAIL
  searchUSEREMAIL(USEREMAIL: any): Observable<any> {

    let params = new HttpParams()
      .set("USEREMAIL", USEREMAIL);

    return this.http.get<any>(`${this.api}/search`, { params: params });
  }

  //GET: Searches for a specific USERNAME
  searchUSERNAME(USERNAME: any): Observable<any> {

    let params = new HttpParams().set("USERNAME", USERNAME);

    return this.http.get<any>(`${this.api}/search`, { params: params });
  }

  //GET: Searches for a specific GROUPID
  searchGROUPNAME(GROUPNAME: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPNAME", GROUPNAME);

    return this.http.get<any>(`${this.api}/search`, { params: params });
  }

  //--------------------------------- GROUP CRUD FUNCTIONALITY ---------------------------------
  /*GET: Gets all group information and members for a specific group divided in 3 arrays for each type of user role. 
  Requires the object as follows {GROUPID : String}*/
  getGroup(group: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPID", group.GROUPID);

    return this.http.get<any>(`${this.api}/group`, { params: params });
  }

  /*GET: Gets all group names for a user, meaning all the groups he's part of with its specific roles.
  Requires the object as follows {USERID : String}*/
  getGroupsUser(user: any): Observable<any> {

    let params = new HttpParams()
      .set("USERID", user.USERID);

    return this.http.get<any>(`${this.api}/user-groups`, { params: params });
  }

  /*POST: Creates a new group. 
    Requires the object as follows {GROUPID : String,  GROUPNAME : String, GROUPSUMMARY: String(256), GROUPPRIVACY : Int, GROUPOWNER : String}*/
  createGroup(group: any): Observable<any> {

    return this.http.post<any>(`${this.api}/group`, group);
  }

  /*PUT: Used to update group information. The object should not contain anything more than GROUPID and one property.
    Requires the object as follows {GROUPID : String, GROUPNAME : String, GROUPSUMMARY: String(256), GROUPPRIVACY : Int, GROUPOWNER : String}*/
  updateGroup(group: any): Observable<any> {

    return this.http.put<any>(`${this.api}/group`, group);
  }

  /*DELETE: Deletes a group. 
    Requires the object as follows {GROUPID : String}*/
  deleteGroup(group: any): Observable<any> {

    let params = new HttpParams().set("GROUPID", group.GROUPID);

    return this.http.delete<any>(`${this.api}/group`, { params: params });
  }

  //--------------------------------- USER ROLES ADD/REMOVE FUNCTIONALITY ---------------------------------
  /*POST: The following functions add a user to a group. 
    Requires the object as follows {GROUPID : String, USERID : String}*/
  addAdmin(role: any): Observable<any> {

    role.TYPE = "ADMIN";
    return this.http.post<any>(`${this.api}/role-add`, role);
  }

  addMember(role: any): Observable<any> {

    role.TYPE = "MEMBER";
    return this.http.post<any>(`${this.api}/role-add`, role);
  }

  addModerator(role: any): Observable<any> {

    role.TYPE = "MODERATOR";
    return this.http.post<any>(`${this.api}/role-add`, role);
  }

  /*DELETE: The following functions remove a user from a group. 
   Requires the object as follows {GROUPID : String, USERID : String}*/
  removeAdmin(role: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPID", role.GROUPID)
      .set("USERID", role.USERID)
      .set("TYPE", "ADMIN");

    return this.http.delete<any>(`${this.api}/role-remove`, { params: params });
  }

  removeMember(role: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPID", role.GROUPID)
      .set("USERID", role.USERID)
      .set("TYPE", "MEMBER");

    return this.http.delete<any>(`${this.api}/role-remove`, { params: params });
  }

  removeModerator(role: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPID", role.GROUPID)
      .set("USERID", role.USERID)
      .set("TYPE", "MODERATOR");

    return this.http.delete<any>(`${this.api}/role-remove`, { params: params });
  }

  //--------------------------------- GROUP MEMBERSHIP REQUEST ---------------------------------
  /*POST: Sends a request to join a group. 
    Requires the object as follows {GROUPID : String, USERID : String}*/
  sendRequest(request: any): Observable<any> {

    return this.http.post<any>(`${this.api}/group-request`, request);
  }

  /*PUT: Alters the request status to 1 when the request is accepted. 
    Requires the object as follows {GROUPID : String, USERID : String}*/
  acceptRequest(request: any): Observable<any> {

    return this.http.put<any>(`${this.api}/group-request`, request);
  }

  /*DELETE: Removes a relationship if its status is 0, if status is 1 an error will be returned.
   When an error occurs it means you should be using removeMember instead of deleteRequest
    Requires the object as follows {GROUPID : String, USERID : String}*/
  deleteRequest(request: any): Observable<any> {

    let params = new HttpParams()
      .set("GROUPID", request.GROUPID)
      .set("USERID", request.USERID);

    return this.http.delete<any>(`${this.api}/group-request`, { params: params });
  }

  //--------------------------------- THREAD CRUD ---------------------------------
  /*IMPORTANT INFORMATION:

    CREATED_BY -> A relevant USERID that indicates which user created the thread
    GROUPID -> Threads belong to groups so the GROUPID must also be relevant
    STATUS -> 0 if the thread is either not approved by a moderator or any 
              other case on which it should not be displayed. 
              (Up to you to decide how to define these permissions)
              1 if the thread has been approved and is set visible.
  */

  /*GET (double functionality): 
  Gets all thread information for a specific thread belonging to a group 
  Requires the object as follows {THREAD_ID : String, GROUPID : String}

  OR 

  Gets all threads belonging a specific group.
  Requires the object as follows {GROUPID : String}*/
  getThread(thread: any): Observable<any> {

    let params = new HttpParams()
      .set("THREAD_ID", thread.THREAD_ID)
      .set("GROUPID", thread.GROUPID);

    return this.http.get<any>(`${this.api}/thread`, { params: params });
  }

  /*POST: Creates a thread for a group
  Requires the object as follows 
  {THREAD_SUBJECT : String, THREAD_TITLE : String, STATUS : NUMBER(0||1), 
    CREATED_BY : String(USERID), GROUPID : String}*/
  createThread(thread: any): Observable<any> {

    return this.http.post<any>(`${this.api}/thread`, thread);
  }

  /*PUT: Updates a THREAD_TITLE and/or THREAD_SUBJECT
  Requires the object as follows 
  {THREAD_ID : String, THREAD_SUBJECT : String, THREAD_TITLE : String, GROUPID : String}*/
  updateThread(thread: any): Observable<any> {

    return this.http.put<any>(`${this.api}/thread`, thread);
  }

  /*PUT: Updates the thread's STATUS
  Requires the object as follows 
  {THREAD_ID : String, STATUS : NUMBER(0||1), GROUPID : String}*/
  changeThreadStatus(thread: any): Observable<any> {

    return this.http.put<any>(`${this.api}/thread-status`, thread);
  }

  /*DELETE: Removes a thread from the DB
  Requires the object as follows 
  {THREAD_ID : String, GROUPID : String}*/
  deleteThread(thread: any): Observable<any> {

    let params = new HttpParams()
    .set("THREAD_ID", thread.THREAD_ID)
    .set("GROUPID", thread.GROUPID);

    return this.http.delete<any>(`${this.api}/thread`, { params: params });
  }

  //--------------------------------- POST CRUD ---------------------------------
  /*IMPORTANT INFORMATION:

    CREATED_BY -> A relevant USERID that indicates which user created the thread
    THREAD_ID -> Posts belong to threads so the THREAD_ID must also be relevant
    STATUS -> 0 if the post is either not approved by a moderator or any 
              other case on which it should not be displayed. 
              (Up to you to decide how to define these permissions)
              1 if the post has been approved and is set visible.
  */

  /*GET (double functionality): 
  Gets all post information for a specific post belonging to a thread 
  Requires the object as follows {POST_ID : String, THREAD_ID : String}

  OR 

  Gets all threads belonging a specific group.
  Requires the object as follows {THREAD_ID : String}*/
  getPost(post: any): Observable<any> {

    let params = new HttpParams()
      .set("THREAD_ID", post.THREAD_ID)
      .set("POST_ID", post.POST_ID);

    return this.http.get<any>(`${this.api}/thread-post`, { params: params });
  }

  /*POST: Creates a post for a thread
  Requires the object as follows 
  {POST_CONTENT : String, STATUS : NUMBER(0||1), 
    CREATED_BY : String(USERID), THREAD_ID : String}*/
  createPost(post: any): Observable<any> {

    return this.http.post<any>(`${this.api}/thread-post`, post);
  }

  /*PUT: Updates a POST_CONTENT
  Requires the object as follows 
  {POST_ID : String, POST_CONTENT : String, THREAD_ID : String}*/
  updatePost(post: any): Observable<any> {

    return this.http.put<any>(`${this.api}/thread-post`, post);
  }

  /*PUT: Updates the post's STATUS
  Requires the object as follows 
  {POST_ID : String, STATUS : NUMBER(0||1), THREAD_ID : String}*/
  changePostStatus(post: any): Observable<any> {

    return this.http.put<any>(`${this.api}/thread-status`, post);
  }

  /*DELETE: Removes a post from the DB
  Requires the object as follows 
  {POST_ID : String, THREAD_ID : String}*/
  deletePost(post: any): Observable<any> {

    let params = new HttpParams()
    .set("THREAD_ID", post.THREAD_ID)
    .set("POST_ID", post.POST_ID);

    return this.http.delete<any>(`${this.api}/thread-post`, { params: params });
  }
}

