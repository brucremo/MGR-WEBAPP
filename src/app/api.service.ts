import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from './user';
import { map } from 'rxjs/operators';

//Headers for requests sent to the API
const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  //API URL
  public api = "https://mgr-restapi.herokuapp.com";

  //For API local testing
  //public api = "http://localhost:8082"
  
  constructor(
    private http: HttpClient
  ) { }

  //--------------------------------- USER INFORMATION REQUESTS ---------------------------------

  //GET: /users (returns all users information except for password)
  getUsers() {

    return this.http.get<User[]>(`${this.api}/users`);
  }

  //GET: /users/:userid (return single user information except for password)
  getUser(user: User): Observable<any> {

    return this.http.get<User>(`${this.api}/users/${user.USERID}`);
  }

  //POST: /users (add user to the system and hash store its password on the database)
  userAdd(user: User): Observable<any> {

    return this.http.post<any>(`${this.api}/users`, user)
      .pipe(map(wrapper => wrapper.message))
  }

  //PUT: /users/:userid (updates single user information)
  useredit(user: User): Observable<any> {

    return this.http.put<any>(`${this.api}/users/${user.USERID}`, user)
      .pipe(map(wrapper => wrapper.message))
  }

  //DELETE: /users/:userid (deletes single user from the database)
  userDelete(user: User) {

    return this.http.delete<User[]>(`${this.api}/users/${user.USERID}`);
  }

  //--------------------------------- PASSWORD MANAGEMENT REQUESTS ---------------------------------

  /*PUT: /users/:userid/pwd -> Checks if the USERNAME + USERPASSWORD pair is valid on logon based on the hashed value stored in the database.*/
  userLogin(user: User): Observable<any> {

    return this.http.put<User>(`${this.api}/users/${user.USERID}/pwd`, user, httpOptions);
  }

  //--------------------------------- PASSWORD RESET REQUESTS ---------------------------------

  /*GET: /:id/reset/:guid -> The GUID is generated by the API and the user will access our website with this link to reset its password. 
  The GUID will be checked for validity, if it is valid it will return a User object with only USERID and USERNAME, otherwise the API will return a 404 error.*/
  userCredentialCheck(user: User, GUID): Observable<any> {

    return this.http.get<User>(`${this.api}/${user.USERID}/reset/${GUID}`);
  }

  /* PUT: /:id/reset/ -> Receives an object with the USERID and USEREMAIL to have its password reset. 
  This function will send the user an Email with instructions to reset its password. 
  The object sent to it must be sent in the following form (notice the single quotes around the Email address, they are required): 
  {"USERID":"usr", "USEREMAIL":"'email@me.com'"} */
  userPasswordReset(user: User): Observable<any> {

    return this.http.put<User>(`${this.api}/${user.USERID}/reset`, user, httpOptions);
  }

  /* POST: /:id/reset -> Receives an object with the USERID and USERPASSWORD to have its password reset. 
  It simply sets the selected user's password to the password provided in the object and returns the object with USERPASSWORD set to true. */
  userPasswordChange(user: User): Observable<any> {

    return this.http.post<User>(`${this.api}/${user.USERID}/reset/`, user);
  }

  //--------------------------------- REVIEW REQUESTS ---------------------------------

  // GET: /reviews/:gameid -> Retrieves all stored reviews for a specific game
  gameGetReviews(gameid: String): Observable<any>{

    return this.http.get<any>(`${this.api}/reviews/${gameid}`);
  }

  // GET: /reviews/:gameid -> Retrieves all stored reviews for a specific game
  userGetReviews(userid: String): Observable<any>{

    return this.http.get<any>(`${this.api}/reviews/user/${userid}`);
  }

  // GET: /review/:gameid/:userid -> Retrieves all stored reviews for a specific game
  getReview(gameid: String, userid: String): Observable<any>{

    return this.http.get<any>(`${this.api}/review/${gameid}/${userid}`);
  }

  /* Object blueprint for POST and PUT ->

    const object = {
        USERID: req.params.userid,
        GAMEID: req.params.gameid,
        REVIEWSUMMARY: req.body.REVIEWSUMMARY,
        REVIEWRATING: req.body.REVIEWRATING,
        GAMEPLATFORM: req.body.GAMEPLATFORM
    };
  */

  /* POST: /review/:gameid/:userid -> Receives an object with USERID, GAMEID, REVIEWSUMMARY, 
  REVIEWRATING and GAMEPLATFORM to be posted for the parameters gameid and userid */
  gameReviewAdd(review: any): Observable<any>{

    return this.http.post<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`, review);
  }

  /* PUT: /review/:gameid/:userid -> Receives an object with USERID, GAMEID, REVIEWSUMMARY, 
  REVIEWRATING and GAMEPLATFORM to be updated for the parameters gameid and userid */
  gameReviewEdit(review: any): Observable<any>{

    return this.http.put<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`, review);
  }

  /* DELETE: /review/:gameid/:userid -> Receives an object with GAMEID and USERID for a review to be deleted from the database */
  gameReviewDelete(review: any): Observable<any>{

    return this.http.delete<any>(`${this.api}/review/${review.GAMEID}/${review.USERID}`);
  }

  //--------------------------------- LIBRARY MANAGEMENT ---------------------------------

  // GET: /library/:userid -> Retrieves all stored games associated with a user library
  getUserLibrary(userid: String): Observable<any>{

    return this.http.get<any>(`${this.api}/library/${userid}`);
  }

  // PUT: /library/:userid/:gameid -> Associates a gameid to a user's library
  addToUserLibrary(userid: String, gameid: String): Observable<any>{

    const lib = {
      USERID : userid,
      GAMEID : gameid
    }

    return this.http.put<any>(`${this.api}/library/${lib.USERID}/${lib.GAMEID}`, lib);
  }

  // DELETE: /library/:userid/:gameid -> Removes a gameid from a user's library
  removeFromUserLibrary(userid: String, gameid: String): Observable<any>{

    return this.http.delete<any>(`${this.api}/library/${userid}/${gameid}`);
  }

  // POST: /library/:userid/:gameid -> Toggles game as favourite for the user's library
  setFavourite(userid: String, gameid: String): Observable<any>{

    const lib = {
      USERID : userid,
      GAMEID : gameid
    }

    return this.http.post<any>(`${this.api}/library/${lib.USERID}/${lib.GAMEID}`, lib);
  }

  //--------------------------------- REGISTRATION TOOLS ---------------------------------

  /* GET: /register/get-email/:email -> Returns true if the e-mail passed as parameter already 
  exists in the DB, false otherwise */
  checkEmailDB(email: String): Observable<any> {

    return this.http.get<any>(`${this.api}/register/get-email/${email}`);
  }

  /* GET: /register/get-userid/:userid -> Returns true if the userid passed as parameter already 
  exists in the DB, false otherwise */
  checkUserIDDB(userid: String): Observable<any> {

    return this.http.get<any>(`${this.api}/register/get-userid/${userid}`);
  }

  //--------------------------------- TAG FUNCTIONALITY ---------------------------------

  // GET: /tag/:tagid/:userid -> Returns all games related to a tag in a user's library
  getGamesForTag(userid: String, tagid: String): Observable<any>{

    return this.http.get<any>(`${this.api}/tag/${tagid}/${userid}`);
  }

  // DELETE: /tag/:tagid/:userid -> Removes a tag from a user's library
  removeTag(userid: String, tagid: String): Observable<any>{

    return this.http.delete<any>(`${this.api}/tag/${tagid}/${userid}`);
  }

  // POST: /tag -> Receives an object with USERID, GAMEID, and TAGS array to be added to a user's library
  /* NOTE -> THE GAME MUST BE ADDED TO THE USER'S LIBARY BEFORE RUNNING THIS FUNCTIONS, IN OTHER WORDS 
  addToUserLibrary MUST BE RUN BEFORE ADD TAG(S)*/
  addTags(tags: any): Observable<any>{

    return this.http.post<any>(`${this.api}/tag`, tags);
  }

  //--------------------------------- FRIEND NETWORKING FUNCTIONALITY ---------------------------------
  //ALL FUNCTIONS GO TO ROUTE /friends AND REQUIRE A JS OBJECT AS DESCRIBED ON THE FOOTPRINTS BELOW

  /* 
    {USER_ONE_ID : String, USER_TWO_ID : String, STATUS: Int, ACTION_USERID : String}

    USER_ONE_ID -> One of the users of the connection, can be either the current user or the user 
    receiving the request.

    USER_TWO_ID -> The other user of the connection, can be either the current user or the user 
    receiving the request. CANNOT BE THE SAME AS USER_ONE_ID
    
    STATUS -> Friendship requests status, used to treat requests and filter friends displays. 
    0 => PENDING | 1 => DECLINED/OK | 2 => DECLINED | 3 => BLOCKED (to be fully implemented later)
    
    ACTION_USERID => Last user to alter the friendship status. MUST BE RELEVANT.
  */

  /*GET: Gets all friends for a specific user. 
    Requires the object as follows {USER_ONE_ID : String, STATUS: Int}*/
  getFriends(relationship: any): Observable<any>{
    let params = new HttpParams().set("USER_ONE_ID", relationship.USER_ONE_ID).set("STATUS", relationship.STATUS);

    return this.http.get<any>(`${this.api}/friends`, {params : params});
  }

  /*POST: Adds user as friend and sends it an e-mail with the request if their relationship does not exist yet. 
    Requires the object as follows {USER_ONE_ID : String, USER_TWO_ID : String, ACTION_USERID : String}*/
  addFriend(relationship: any): Observable<any>{
    return this.http.post<any>(`${this.api}/friends`, relationship);
  }

  /*PUT: Updates friendship status between users. 
    Requires the full object with relevant information regarding ACTION_USERID and STATUS*/
  updateFriend(relationship: any): Observable<any>{

    return this.http.put<any>(`${this.api}/friends`, relationship);
  }

  /*PUT: Removes friendship links between users. 
    Requires the object as follows {USER_ONE_ID : String, USER_TWO_ID : String}*/
  deleteFriend(relationship: any): Observable<any>{
    let params = new HttpParams().set("USER_ONE_ID", relationship.USER_ONE_ID).set("USER_TWO_ID", relationship.USER_TWO_ID);

    return this.http.delete<any>(`${this.api}/friends`, {params : params});
  }

  //--------------------------------- GROUP/USER SEARCH FUNCTIONALITY ---------------------------------
  /*GET: Pass an object with the desired search parameter. The object should have only one property being either:
  
    => returns a group object with GROUPID
    GROUPID -> to search for a group based on ID          

    => returns a user object with USERID, USERNAME, USERAVATAR, USERSUMMARY and USERLOCATION
    USEREMAIL -> to search for a user based on its email 
    USERID -> to search for a user based on id 
    USERNAME -> to search for a user based on its name
  */
 search(searchObject: any): Observable<any> {

  if (searchObject.GROUPID) {

    let params = new HttpParams().set("GROUPID", searchObject.GROUPID);

    return this.http.get<any>(`${this.api}/search`, { params: params });
  } else {

    if (searchObject.USEREMAIL) {

      let params = new HttpParams().set("USEREMAIL", searchObject.USEREMAIL);

      return this.http.get<any>(`${this.api}/search`, { params: params });

    } else if (searchObject.USERID) {

      let params = new HttpParams().set("USERID", searchObject.USERID);

      return this.http.get<any>(`${this.api}/search`, { params: params });

    } else {

      let params = new HttpParams().set("USERNAME", searchObject.USERNAME);

      return this.http.get<any>(`${this.api}/search`, { params: params });
    }
  }
}
}

  